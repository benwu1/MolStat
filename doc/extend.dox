/* This file is a part of MolStat, which is distributed under the Creative
   Commons Attribution-NonCommercial 4.0 International Public License.
   MolStat (c) 2014, Northwestern University. */
/**
\page extend_molstat Extending MolStat

This chapter describes how to extend the functionality of MolStat.
\ref sec_add_general describes how to add, e.g.,\ random number distributions
and histogram binning styles. \ref sec_add_simulate describes how to add
simulator models and observables. \ref sec_add_fit describes how to add fitter
models. The implementation and incorporation of any of these concepts into
MolStat is designed to be straightforward.

\section sec_add_general Adding General Mathematical Operations

\subsection subsec_add_rnd Adding Random Number Distributions
Random number distributions are computationally described by the
RandomDistribution class. Adding a new random number distribution requires
a class derived from RandomDistribution that implements the `sample` function.
This function takes in a `gsl_rng` construct from GSL and returns a random
number from the distribution.

Finally, the new random number distribution needs to be added to the
::distribution_from_tokens function so that it is processed from input. In this
function, the `distribution` tag for the input deck is defined and the code for
processing `[distribution-parameters]` is implemented. The implemented
distributions should provide sufficient examples. Note that the name of the
distribution should be in lowercase.

\subsection subsec_add_binstyle Adding Binning Styles
Binning styles are described by the abstract BinStyle class. Adding a new
binning style required deriving from this class and implementing the three
abstract functions.
-# The mask function, \f$u = f(x)\f$, in `mask`.
-# The inverse mask function, \f$x = f^{-1}(u)\f$, in `invmask`.
-# The derivative of the mask function, \f$ \mathrm{d}f / \mathrm{d}x\f$, in
   `dmaskdx`.
.
When the new binning style is used, the set \f$\{f(x)\}\f$ is binned.

Finally, add the new binning style class to the ::get_bin_style function so that
it can be referenced from the input arguments. The implemented examples should
be sufficient to explain this procedure. Note that the name of the binning
style should be in lowercase.

\section sec_add_simulate Adding Simulator Models and Observables

\subsection subsec_add_simulate_observable Adding Simulator Observables

\subsection subsec_add_simulate_model Adding Simulator Models
Simulator models are encapsulated by the SimulateModel class. This base class
- stores a list of the random number distributions, as specified by the
  derived class.
- samples from all of the random number distributions, given a GSL random
  number generator.
.
The derived class for a new simulator model needs to specify the names of its
parameters when calling the constructor for SimulateModel. The order of the
parameters is important, the `std::vector<double>` produced by
SimulateModel::sample will be ordered the same way. (Implemented models have
the `unpack_parameters` function to aid in this process.) A constant, static
member of each class usually lists the names, in order. The new class must have
a constructor with the signature
\verbatim
NewSimulateModel(const std::map<std::string, std::shared_ptr<RandomDistribution>> &)
\endverbatim
This function passes the list of available random distributions to the
SimulateModel constructor, along with the list of required parameters.

Although the above steps are all that is necessary for making a simulator
model, the resulting model would not be very useful. A simulator model should
also inherit from one or more observable classes and implement each
observable's function (see \ref subsec_add_simulate_observable). To this end,
implemented simulator models usually have a static member function that
calculates the observable for a specific set of parameters. (Recall that the
observable's function will randomly generate data *and* subsequently calculate
the observable.)

Finally, the new simulator model needs to be added to to the simulator's
`models` list. The ::SimulateModelAdd template provides a wrapper for this
operation; using SymOneSiteSimulateModel as an example, the code would be
\verbatim
models["symmetriconesite"] = SimulateModelAdd<SymOneSiteSimulateModel>();
\endverbatim
The name of the model (for use in the input file) is the key for `models`. This
key should be in lowercase in the code; it is case insensitive in the input
file.

\section sec_add_fit Adding Fitter Models

Adding a conductance model is designed to be straightforward, requiring the
following steps.
-# Derive a class from ConductanceModel, implementing the ConductanceModel::static_conductance, ConductanceModel::diff_conductance, and ConductanceModel::zero_bias_conductance member functions. As a side note, these three functions may use the transmission function, or other model-specific functions, which are implemented as static member functions of the derived class (as needed).
-# Add a case for the new model in the ::make_model function. This block of code should check that all necessary random number distributions are specified and properly route them to the ConductanceModel. Finally, the case returns a shared pointer to the ConductanceModel. The implemented cases should provide sufficient examples. Note that the name of the model should be in lowercase.
-# Add a note to the end of the ::make_model function so that (minimal) runtime support is present.

\section sec_cond_hist_fit Fitting Conductance Histograms
The general procedure for fitting a conductance histogram is as follows.
Specify
- a model line shape to fit against the conductance histogram. Each model has
several parameters, as detailed below.
- a file name containing the conductance histogram data.
- additional options (if desired; none are required).

From this information, the fitter reads in the conductance histogram and uses
GSL's non-linear least-squares routines to fit the histogram to the desired
line shape. Because non-linear least-squares fits are not guaranteed to find
the best-fit solutions, we use multiple initial guesses and report the best
fit across all guesses. This still doesn't guarantee the best fit, but seems to
work well, in practice.

Following is an example input file.
\verbatim
SymmetricNonresonant
1,4-dithiolbenzene.dat
noprint
guess c 50. d 6. norm 10.
guess default
bin linear
\endverbatim
Additional example inputs can be found in the tests; see
fit-asymmetric-resonant.py, fit-symmetric-nonresonant.py, and/or
fit-symmetric-resonant.py.

The lines are interpreted as follows.
-# The model to use when fitting the conductance histogram.
-# The data file containing the conductance histogram. All fitting models (so
   far) are for 1-D histograms. The file should have two numbers per line: the
   conductance, and the histogram counts in this bin.
-# All following lines are optional and have the form `command options`.
   The commands, and any options they require, are
   - `noprint` (recommended) -- only output the best fit parameters at the end
     of the program.
   - `print` -- output iteration-by-iteration results for all initial guesses.
     This can produce a large amount of output.
   - `guess` -- specify initial guess(es) to use. Multiple `guess` commands
     may be present.
     - `guess default` -- load a \"default\" set of initial guesses for the
       model. If no other initial guesses are specified, these initial guesses
       will be automatically loaded. This command may be present with other
       user-specified initial guesses to use both the user-specified and
       default sets.
     - `guess name value ...` -- add a user-specified initial guess. After the
       `guess` command is a list of name/value pairs. Each fit parameter
       (remember that fit parameters depend on the model) must be given an
       initial value. All name/value pairs should appear on the same line. See
       an example of this syntax in the above example input file. The \"norm\"
       parameter (\f$N\f$) does not need to be specified, but it can be.
   - `bin` -- specify the binning status of the data to be read in. If the data
     is in `g counts` form (as is produced by the simulator), use
     `bin linear`. If no `bin` command is issued, `linear` is the default. See
     \ref subsec_impl_binstyle for a list of implemented binning types.
     \note The use of non-`linear` binning styles is provided for cases where
        the user may want to fit data that is not produced from the simulator
        and was binned, e.g., logarithmically without converting back to
        \f$g\f$. In this case, the histogram would estimate
        \f$P_{\ln(\hat{g})}(\ln(g))\f$, not \f$P_{\hat{g}}(g)\f$; the fitter
        needs to account for this disparity.

\subsection subsec_implemented_fits Implemented Fitting Models
We now list the implemented models for fitting conductance histograms. Note
that all of these models are implemented by classes derived from `FitModel`.
`FitModel` handles most all of the interface to the GSL routines, leaving only
the model-dependent details to the specific subclass.
- `SymmetricNonresonantFitModel`
   - Nonresonant tunneling through a single channel that is symmetrically
     connected to the two leads. This model was derived with electron transport
     through molecules in mind.
   - Implemented by the class SymmetricNonresonantFitModel; full details are
     presented there.
   - Fitting parameters (dimensionless) are
       - \f$c\f$, the average level alignment relative to the standard deviation
         in channel-electrode coupling.
       - \f$d\f$, the average channel-electrode coupling relative to its
         standard deviation.
       - \f$ N \f$, a scale parameter (since the histogram is probably
         unnormalized).
   - Fits may be unreliable if the conductance histogram peak occurs at
     \f$ g \gtrsim 0.01 \f$ \f$\mathrm{G}_0\f$.
   - Detailed in \cite williams-5937.

- `SymmetricResonantFitModel`
   - Resonant tunneling through a single channel that is symmetrically
     connected to the two leads.
   - Implemented by the class SymmetricResonantFitModel; full details are
     presented there.
   - Fitting parameters (dimensionless) are
       - \f$ \gamma \f$, the average channel-electrode coupling relative to the
         standard deviation in the level alignment.
       - \f$ N \f$, a scale parameter (since the histogram is probably
         unnormalized).
   - Detailed in \cite williams-5937.

- `AsymmetricResonantFitModel`
   - Resonant tunneling through a single channel that is asymmetrically
     connected to the two leads. This model was derived with electron transport
     through point contacts in mind.
   - Implemented by the class AsymmetricResonantFitModel; full details are
     presented there.
   - Fitting parameters (dimensionless) are
       - \f$ \gamma_\mathrm{L} \f$, the average coupling to one electrode
         relative to the standard deviation in the couplings.
       - \f$ \gamma_\mathrm{R} \f$, the average coupling to the other
         electrode relative to the standard deviation in the couplings.
       - \f$ r \f$, the standard deviaton of the coupling relative to the
         standard deviation of the level alignment.
       - \f$ N \f$, a scale parameter (since the histogram is probably
         unnormalized).
   - Fits are somewhat insensitive to \f$r\f$.
   - The order of \f$\Gamma_\mathrm{L}\f$ and \f$\Gamma_\mathrm{R}\f$ is
     arbitrary.
   - Detailed in \cite williams-5937.

\subsection subsec_add_fit_models Adding Fitting Models
Adding a model to fit against is designed to be straightforward. First, we
describe the general steps of non-linear fitting and then outline how to add
a model.

Non-linear fitting a really an optimization process. Suppose our observed data
set is \f$\{g_j, p_j\}\f$; perhaps, as is the case for 1D conductance
histograms, \f$j\f$ is a bin, \f$g_j\f$ is the conductance of that bin, and
\f$p_j\f$ is the bin count. We ultimately seek to minimize a functional such
as \f[ r(\{g_j, p_j\}; \{x_k\}) = \sum_j \left| f(g_j; \{x_k\}) - p_j \right|^2, \f] where
\f$f\f$ is the fit function and \f$\{ x_k \}\f$ are the fitting parameters.

Much of the fitting procedure is handled internally by the GSL, and the
`FitModel` class contains even more common operations. Ultimately, to implement
a new model,
-# Derive a class from FitModel, implementing the FitModel::resid and
   FitModel::jacobian member functions. FitModel::resid calculates the
   component in \f$r\f$ for a particular data point \f$g_j\f$ and \f$p_j\f$.
   Similarly, FitModel::jacobian calculates the Jacobian at the specific data
   point, where the Jacobian is the vector of \f$\partial f / \partial x_k\f$
   derivatives.
-# If the functional form and/or its Jacobian are expensive to calculate, you
   may wish to override the FitModel::resid_j function, which evaluates the
   residual and Jacobian together. The default provided by FitModel simply
   calls the subclass's `resid` and `jacobian` functions.
-# Implement the member function FitModel::append_default_guesses, which
   populates  a vector of initial guesses to use for fitting the data. The fit
   will be performed for each initial guess, and the best fit will be output at
   the end. Similarly, implement the FitModel::create_initial_guess function,
   which facilitates runtime-specified initial guesses.
-# Implement the member function FitModel::print_fit, which prints a set of
   fitting parameters to the specified output stream.
-# If deemed necessary, override the FitModel::process_fit_parameters, which
   \"cleans\" up the parameters. For instance, the \f$\gamma\f$ parameter in
   the SymmetricResonantFitModel may be mathematically positive or negative
   (the fit function only depends on \f$\gamma^2\f$), but physically it should
   be positive. This function ensures that, in this example, \f$\gamma>0\f$.
-# Add the model, using an input name, to the ::get_cond_hist_fit_model
   function. Also consider adding a note to the error message so as to provide
   (minimal) runtime support.
*/
